name: Deploy API to AWS Lambda

on:
  push:
    branches: [main]
  workflow_dispatch:

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Generate version
        id: version
        run: |
          BASE_VERSION=$(node -p "require('./apps/api/package.json').version")
          GIT_SHA_SHORT=$(git rev-parse --short HEAD)
          APP_VERSION="${BASE_VERSION}-${GIT_SHA_SHORT}"
          echo "version=${APP_VERSION}" >> $GITHUB_OUTPUT
          echo "sha=${GIT_SHA_SHORT}" >> $GITHUB_OUTPUT
          echo "üì¶ Version: ${APP_VERSION}"

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22.19.0'

      - name: Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: 10.12.1

      - name: PNPM config
        run: |
          # Enable injecting workspace packages in pnpm, needed for pnpm deploy command
          pnpm config set inject-workspace-packages=true --location project
          # Hack to keep lock file check happy
          yq -i '.settings.injectWorkspacePackages = true' pnpm-lock.yaml

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Prepare deployment package
        run: |
          echo "Building with version: ${{ steps.version.outputs.version }}"
          # Create version.json in the source before building
          echo '{"version":"${{ steps.version.outputs.version }}"}' > ./apps/api/src/version.json
          pnpm build --filter=api
          pnpm --filter=api --prod deploy ./api-deploy
          cd ./api-deploy
          mv ./dist/* .
          rmdir ./dist
          echo "‚úÖ Version file created with: ${{ steps.version.outputs.version }}"

      - name: Clean up deployment directory
        run: |
          cd ./api-deploy
          rm -rf ./src
          find . -name "*.ts" -type f -delete
          find . -name "*.map" -type f -delete
          echo "üßπ Cleaned up deployment directory"

      - name: Package deployment zip
        run: |
          cd ./api-deploy
          TIMESTAMP=$(date +%Y%m%d-%H%M%S)
          ZIP_FILE="lambda-deployment-${TIMESTAMP}.zip"
          zip --symlinks -r -q "$ZIP_FILE" .
          echo "ZIP_FILE=${ZIP_FILE}" >> $GITHUB_ENV
          echo "üì¶ Created deployment package: $ZIP_FILE ($(du -h "$ZIP_FILE" | cut -f1))"

      - name: Smoke test - Start built API from zip
        env:
          EXPECTED_VERSION: ${{ steps.version.outputs.version }}
        run: |
          cd ./api-deploy

          # Extract zip to a test directory
          TEST_DIR="./test-extract"
          mkdir -p "$TEST_DIR"
          unzip -q "${{ env.ZIP_FILE }}" -d "$TEST_DIR"
          echo "üì¶ Extracted zip for testing"

          cd "$TEST_DIR"
          timeout 10s node index.js &
          SERVER_PID=$!

          # Wait for server to start
          echo "‚è≥ Waiting for server to start..."
          for i in {1..30}; do
            if curl -f http://localhost:3001/health > /dev/null 2>&1; then
              echo "‚úÖ Server started successfully!"
              curl -s http://localhost:3001/health | jq .
              kill $SERVER_PID 2>/dev/null || true
              exit 0
            fi
            sleep 1
          done

          echo "‚ùå Server failed to start"
          kill $SERVER_PID 2>/dev/null || true
          exit 1

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1

      - name: Get Lambda configuration from AWS Secrets Manager
        id: lambda-config
        run: |
          LAMBDA_BUCKET=$(aws secretsmanager get-secret-value --secret-id pack-pixie/lambda-bucket --query SecretString --output text)
          LAMBDA_FUNCTION=$(aws secretsmanager get-secret-value --secret-id pack-pixie/lambda-function --query SecretString --output text)
          echo "bucket=${LAMBDA_BUCKET}" >> $GITHUB_OUTPUT
          echo "function=${LAMBDA_FUNCTION}" >> $GITHUB_OUTPUT

      - name: Upload to S3
        run: |
          aws s3 cp ./api-deploy/${{ env.ZIP_FILE }} s3://${{ steps.lambda-config.outputs.bucket }}/${{ env.ZIP_FILE }}
          echo "‚òÅÔ∏è Uploaded to S3"

      - name: Update Lambda function
        run: |
          aws lambda update-function-code \
            --function-name ${{ steps.lambda-config.outputs.function }} \
            --s3-bucket ${{ steps.lambda-config.outputs.bucket }} \
            --s3-key ${{ env.ZIP_FILE }} \
            --publish

      - name: Wait for Lambda to be ready
        run: |
          aws lambda wait function-updated \
            --function-name ${{ steps.lambda-config.outputs.function }}
          echo "‚úÖ Lambda function updated successfully!"

      - name: Get API Gateway URL from AWS Secrets Manager
        id: api-url
        run: |
          API_URL=$(aws secretsmanager get-secret-value --secret-id pack-pixie/api-gateway-url --query SecretString --output text 2>/dev/null || echo "")
          if [ -n "$API_URL" ]; then
            echo "üåê API Gateway URL: ${API_URL}"
            echo "Testing endpoints:"
            echo "  Health: ${API_URL}/health"
            echo "  Status: ${API_URL}/api/status"
            echo "  Hello:  ${API_URL}/api/hello"
            echo "api_url=${API_URL}" >> $GITHUB_OUTPUT
          fi

      - name: Verify deployment - Call status endpoint
        env:
          EXPECTED_VERSION: ${{ steps.version.outputs.version }}
        run: |
          if [ -z "${{ steps.api-url.outputs.api_url }}" ]; then
            echo "‚ùå API URL not found - cannot verify deployment"
            exit 1
          fi

          echo "üîç Testing status endpoint..."
          echo "Expected version: $EXPECTED_VERSION"

          # Retry logic for Lambda cold start
          MAX_RETRIES=5
          RETRY_DELAY=3

          for attempt in $(seq 1 $MAX_RETRIES); do
            echo "Attempt $attempt/$MAX_RETRIES..."
            
            RESPONSE=$(curl -s -w "\n%{http_code}" "${{ steps.api-url.outputs.api_url }}/api/status")
            HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
            BODY=$(echo "$RESPONSE" | head -n-1)

            echo "HTTP Status: $HTTP_CODE"
            echo "Response:"
            echo "$BODY" | jq . || echo "$BODY"

            if [ "$HTTP_CODE" = "200" ]; then
              # Verify version
              ACTUAL_VERSION=$(echo "$BODY" | jq -r '.version')
              echo "Actual version: $ACTUAL_VERSION"
              
              if [ "$ACTUAL_VERSION" = "$EXPECTED_VERSION" ]; then
                echo "‚úÖ Deployment verified! Version matches: $ACTUAL_VERSION"
                exit 0
              else
                echo "‚ùå Version mismatch! Expected: $EXPECTED_VERSION, Got: $ACTUAL_VERSION"
                if [ $attempt -lt $MAX_RETRIES ]; then
                  echo "Retrying in ${RETRY_DELAY}s..."
                  sleep $RETRY_DELAY
                else
                  exit 1
                fi
              fi
            else
              echo "‚ùå Status endpoint returned HTTP $HTTP_CODE"
              if [ $attempt -lt $MAX_RETRIES ]; then
                echo "Retrying in ${RETRY_DELAY}s..."
                sleep $RETRY_DELAY
              else
                exit 1
              fi
            fi
          done

          echo "‚ùå Deployment verification failed after $MAX_RETRIES attempts"
          exit 1
